package MUDROD.SessionRecon;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;

import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.common.joda.time.Seconds;
import org.elasticsearch.common.joda.time.format.DateTimeFormatter;
import org.elasticsearch.common.joda.time.format.ISODateTimeFormat;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.sort.SortOrder;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import MUDROD.Datamining.logAnalyzer.ClickThroughData;
import MUDROD.Datamining.logAnalyzer.KeywordPairData;
import Utils.ESNodeClient;

public class Session implements Comparable<Session> {
	private String start;
	private String end;
	private String id;
	private String newid = null;
	String index;

	private ESNodeClient esnode;
	
	public Session(String index, ESNodeClient node) {
		this.index = index;
		this.esnode = node;
	}
	
	DateTimeFormatter fmt = ISODateTimeFormat.dateTime();

	public Session(String Start, String end, String id) {
		super();
		this.start = start;
		this.end = end;
		this.id = id;
	}

	public String getID() {
		return id;
	}

	public String getNewID() {
		return newid;
	}

	public String setNewID(String str) {
		return newid = str;
	}

	public String getStartTime() {
		return start;
	}

	public String getEndTime() {
		return end;
	}

	public int compareTo(Session o) {
		// TODO Auto-generated method stub
		// String compareEnd = o.end;
		fmt.parseDateTime(this.end);
		fmt.parseDateTime(o.end);
		// ascending order
		int result = Seconds.secondsBetween(fmt.parseDateTime(o.end), fmt.parseDateTime(this.end)).getSeconds();

		return result;
	}

	public JsonObject getSessionDetail(String cleanuptype, String SessionID) throws UnsupportedEncodingException{

		JsonObject SessionResults = new JsonObject();
		Gson gson = new Gson();	
		
		//for session tree
		JsonObject JsonTree = this.genSessionTree(cleanuptype, SessionID);
		SessionResults.add("treeData", JsonTree.get("treeData"));
        SessionResults.add("RequestList",JsonTree.get("RequestList"));
        
        //for comments
        SearchResponse comments = esnode.client.prepareSearch(this.index)
		        .setTypes("commentType")		        
		        .setQuery(QueryBuilders.termQuery("SessionID", SessionID))
		        .setSize(100)
		        .addSort("PostDate",SortOrder.DESC)  
		        .execute()
		        .actionGet();
		
        List<JsonObject> commentList = new ArrayList<JsonObject>();  
        for (SearchHit hit : comments.getHits().getHits()) {
        	Map<String,Object> result = hit.getSource();
        	String Date = (String) result.get("PostDate");
        	String Who = (String) result.get("Who");
        	String Generation = (String) result.get("Generation");
        	String Sub = (String) result.get("Sub");
        	String Cor = (String) result.get("Cor");
        	String Com = (String) result.get("Comment");
        	String id = hit.getId();
        	
        	JsonObject comment = new JsonObject();
        	comment.addProperty("Posted Date", Date);
        	comment.addProperty("Posted by", Who);
        	comment.addProperty("Generated by", Generation);
        	comment.addProperty("Should be split", Sub);
        	comment.addProperty("Whether keywords are related", Cor);
        	comment.addProperty("Comment", Com);
        	comment.addProperty("id", id);
        	commentList.add(comment);       
        }
        
        JsonElement JsonComments = gson.toJsonTree(commentList);
        SessionResults.add("Comments",JsonComments);
        
        //keywords
        SearchResponse keywords = esnode.client.prepareSearch(this.index)
		        .setTypes("testlog_cleanup_referer_sessions")		        
		        .setQuery(QueryBuilders.termQuery("SessionID", SessionID))
		        .setSize(100)		       
		        .execute()
		        .actionGet();
		
        List<JsonObject> keywordsList = new ArrayList<JsonObject>();  
        for (SearchHit hit : keywords.getHits().getHits()) {
        	Map<String,Object> result = hit.getSource();
        	String kws = (String) result.get("keywords");
        	JsonObject kw = new JsonObject();
        	kw.addProperty("keywords", kws);
        	keywordsList.add(kw);       
        }
        
        JsonElement JsonKeywords = gson.toJsonTree(keywordsList);
        SessionResults.add("keywords",JsonKeywords);
		//System.out.print(SessionResults.toString());  
		
        return SessionResults;		
	}
	
	public JsonObject genSessionTree(String cleanuptype, String SessionID) throws UnsupportedEncodingException{
		SearchResponse response = esnode.client.prepareSearch(this.index)
		        .setTypes(cleanuptype)		        
		        .setQuery(QueryBuilders.termQuery("SessionID", SessionID))
		        .setSize(100)
		        .addSort("Time",SortOrder.ASC)  
		        .execute()
		        .actionGet();
		int size  = response.getHits().getHits().length;

        Gson gson = new Gson();		
        List<JsonObject> requestList = new ArrayList<JsonObject>();
        SessionTree tree = new SessionTree();   
        int seq = 1;
        for (SearchHit hit : response.getHits().getHits()) {
        	Map<String,Object> result = hit.getSource();
        	String request = (String) result.get("Request");
        	String requestUrl = (String) result.get("RequestUrl");
        	String time = (String) result.get("Time");
        	String logType = (String) result.get("LogType");
        	String referer = (String) result.get("Referer");
        	
        	JsonObject req = new JsonObject();
    		req.addProperty("Time", time);
    		req.addProperty("Request", request);
    		req.addProperty("RequestURL", requestUrl);
    		req.addProperty("LogType", logType);
    		req.addProperty("Referer", referer);
    		req.addProperty("Seq", seq);
    		requestList.add(req);       
    		
    		TreeNode node = new TreeNode(request, logType, referer, time, seq);
    		tree.insert(node);   
    		seq ++;
        }
        
        JsonElement jsonElement = gson.toJsonTree(requestList);
        JsonObject jsonTree = tree.TreeToJson(tree.root);  
        JsonObject SessionTreeJson = new JsonObject();
        SessionTreeJson.add("treeData", jsonTree);
        SessionTreeJson.add("RequestList",jsonElement);

        return SessionTreeJson;
	}
	
	public List<ClickThroughData> genClickThroughData(String index,String cleanuptype, String SessionID) throws UnsupportedEncodingException{
		SearchResponse response = esnode.client.prepareSearch(index)
		        .setTypes(cleanuptype)		        
		        .setQuery(QueryBuilders.termQuery("SessionID", SessionID))
		        .setSize(100)
		        .addSort("Time",SortOrder.ASC)  
		        .execute()
		        .actionGet();
		int size  = response.getHits().getHits().length;

        Gson gson = new Gson();		
        SessionTree tree = new SessionTree();   
        int seq = 1;
        for (SearchHit hit : response.getHits().getHits()) {
        	Map<String,Object> result = hit.getSource();
        	String request = (String) result.get("Request");
        	String requestUrl = (String) result.get("RequestUrl");
        	String time = (String) result.get("Time");
        	String logType = (String) result.get("LogType");
        	String referer = (String) result.get("Referer");
 
    		TreeNode node = new TreeNode(request, logType, referer, time, seq);
    		tree.insert(node);   
    		seq ++;
        }
        
        //get view node
        List<TreeNode> viewnodes = tree.getViewNodes(tree.root);
        //System.out.print("viewnodes:"+ viewnodes.size()+"\n");
        
        //gen click through data
        List<ClickThroughData> clickthroughs = tree.genClickThroughData(viewnodes);
        for(int i=0; i<clickthroughs.size(); i++){
        	clickthroughs.get(i).setSessionId(SessionID);
        	clickthroughs.get(i).setType(cleanuptype);
        }
        
        return clickthroughs;
	}
	
	public List<KeywordPairData> genKeywordPairs(String cleanuptype, String SessionID, String SessionTime) throws UnsupportedEncodingException{
		SearchResponse response = esnode.client.prepareSearch(this.index)
		        .setTypes(cleanuptype)		        
		        .setQuery(QueryBuilders.termQuery("SessionID", SessionID))
		        .setSize(100)
		        .addSort("Time",SortOrder.ASC)  
		        .execute()
		        .actionGet();
		int size  = response.getHits().getHits().length;

        Gson gson = new Gson();		
        SessionTree tree = new SessionTree();   
        int seq = 1;
        for (SearchHit hit : response.getHits().getHits()) {
        	Map<String,Object> result = hit.getSource();
        	String request = (String) result.get("Request");
        	String requestUrl = (String) result.get("RequestUrl");
        	String time = (String) result.get("Time");
        	String logType = (String) result.get("LogType");
        	String referer = (String) result.get("Referer");
 
    		TreeNode node = new TreeNode(request, logType, referer, time, seq);
    		tree.insert(node);   
    		seq ++;
        }
        
        //get view node
        List<TreeNode> downloadnodes = tree.getDownLoadNodes(tree.root);
        //System.out.print("downloadnodes:"+ downloadnodes.size()+"\n");
        
        //gen keyword pair data
        List<KeywordPairData> keywordPairs = tree.genKeywordPairData(downloadnodes);
        for(int i=0; i<keywordPairs.size(); i++){
        	keywordPairs.get(i).setSessionId(SessionID);
        	keywordPairs.get(i).setTime(SessionTime);
        	
        	//keywordPairs.get(i).setType(cleanuptype);
        }
        
        return keywordPairs;
	}
	
	public List<KeywordPairData> genQueryFilterPairs(String cleanuptype, String SessionID, String SessionTime) throws UnsupportedEncodingException, InterruptedException, ExecutionException{
		SearchResponse response = esnode.client.prepareSearch(this.index)
		        .setTypes(cleanuptype)		        
		        .setQuery(QueryBuilders.termQuery("SessionID", SessionID))
		        .setSize(100)
		        .addSort("Time",SortOrder.ASC)  
		        .execute()
		        .actionGet();
		int size  = response.getHits().getHits().length;

        Gson gson = new Gson();		
        SessionTree tree = new SessionTree();   
        int seq = 1;
        for (SearchHit hit : response.getHits().getHits()) {
        	Map<String,Object> result = hit.getSource();
        	String request = (String) result.get("Request");
        	String requestUrl = (String) result.get("RequestUrl");
        	String time = (String) result.get("Time");
        	String logType = (String) result.get("LogType");
        	String referer = (String) result.get("Referer");
 
    		TreeNode node = new TreeNode(request, logType, referer, time, seq);
    		tree.insert(node);   
    		seq ++;
        }
        
        //get view node
        List<TreeNode> viewnodes = tree.getViewNodes(tree.root);

        //gen keyword pair data
        List<KeywordPairData> keywordPairs = tree.genQueryFilterPairs(viewnodes);
        for(int i=0; i<keywordPairs.size(); i++){
        	keywordPairs.get(i).setSessionId(SessionID);
        	keywordPairs.get(i).setTime(SessionTime);
        }
        
        return keywordPairs;
	}
}
